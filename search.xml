<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[同一页面巧妙使用多个element-ui的upload组件]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%90%8C%E4%B8%80%E9%A1%B5%E9%9D%A2%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAelement-ui%E7%9A%84upload%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[问题最近在使用SSR(服务器端渲染)方式引入vue+element-ui开发一个商城项目的时候遇到一个问题:因为商城的订单是可能包含多个商品,所以订单的评价涉及到同一个页面多组表单的异步提交(每一组表单包含评价内容和上传的多张图片)由于element-ui的upload组件默认没有提供多个组件在同一页面绑定不同模型的接口,因此在网上搜了一下,搜到了这篇文章,文章中最后的建议是自己封装一个组件来调用upload组件,使用的时候直接调用自己封装的这个组件,但是项目时间紧迫,我这边希望更快的搞定这个问题,于是想到了以下办法 解决方法在upload组件的接口中,有一个data接口,可以绑定需要上传的除文件之外的其他数据对象,由于订单评价页的一个特点:每个商品不论数量大小都只会被评价一次,因此此处直接将当前数组中商品的uuid绑定到data并传递至上传接口,此操作后表单提交的payload就会包含类似如下数据:123Content-Disposition: form-data; name="uuid"E7D947BA-79F1-11E8-B786-00163E063020 而后台文件上传位置可以做一个判断:如果接收的上传请求包含额外参数,则全部原路返回,因此在上传成功后又会在on-success这个钩子接收到这个唯一的uuid,此处对当前页面商品数组进行遍历并进行比对,在包含返回的uuid对应数组的对应保存组图路径的数组push当前上传成功的图片路径 12345this.data.goods_list.forEach((e,k)=&gt;&#123; if(e.uuid === response.uuid)&#123; e.evaluate.thumbs.push(response.url) &#125;&#125;) 以下是完整代码(html):12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;div class="userEva-cont" v-for="(item,key) in data.goods_list"&gt; &lt;table class="userEva-table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width="420"&gt;商品&lt;/th&gt; &lt;th width="280"&gt;型号&lt;/th&gt; &lt;th width="280"&gt;数量&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;div class="evaluate-pic"&gt;&lt;a :href="'/product/'+item.goods_id+'.html'"&gt;&lt;img :src="'__PHOTO__'+item.thumb"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class="evaluate-text"&gt; &lt;h3&gt;&lt;a&gt;&#123;&#123;item.goods_name&#125;&#125;&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;编号：&#123;&#123;item.uuid&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;td&gt;型号：&#123;&#123;item.goods_specification_name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.num&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="evaluate-wrap"&gt; &lt;form&gt; &lt;dl&gt; &lt;dt&gt;评论：&lt;/dt&gt; &lt;dd&gt; &lt;textarea v-model="item.evaluate.content" placeholder="评论内容"&gt;&lt;/textarea&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;晒单：&lt;/dt&gt; &lt;dd&gt; &lt;el-upload class="upload-demo" :action="basePath" :on-preview="handlePreview" :on-remove="handleRemove" drag multiple :data="item" :limit="5" :on-success="setFileList" list-type="picture"&gt; &lt;i class="el-icon-upload"&gt;&lt;/i&gt; &lt;div class="el-upload__text"&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt; &lt;div class="el-upload__tip" slot="tip"&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div class="evaluate-btns"&gt; &lt;button type="button" class="evaluate-sub" @click="submit(item.evaluate,item)"&gt;提交评价&lt;/button&gt; &lt;label&gt;&lt;input type="checkbox" class="evaluate-show" v-model="item.evaluate.is_anonymous"&gt;匿名评价&lt;/label&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* * todo:初始化vue * */var app = new Vue(&#123; el: '#container', data: &#123; data: __PAGE_DATA__, evaluateUrl: '/evaluate.html', imgDialogVisible: false, tempPath: '', basePath: '' &#125;, mounted() &#123; this.basePath = Vue.prototype.fileUploadBasePath &#125;, methods: &#123; handleRemove(file, fileList) &#123; this.data.goods_list.forEach((e,k)=&gt;&#123; if(e.uuid === file.response.uuid)&#123; //找到当前url下标 const index = e.evaluate.thumbs.indexOf(file.response.url) if(index !== -1)&#123; //删除 e.evaluate.thumbs.splice(index,1) &#125; &#125; &#125;) &#125;, handlePreview(file) &#123; this.tempPath = file.response.url this.imgDialogVisible = true &#125;, setFileList(response, file, fileList)&#123; this.data.goods_list.forEach((e,k)=&gt;&#123; if(e.uuid === response.uuid)&#123; e.evaluate.thumbs.push(response.url) &#125; &#125;) &#125;, submit(evaluate,item)&#123; evaluate.id = item.goods_id evaluate.goods_name = item.goods_name evaluate.goods_specification_name = item.goods_specification_name evaluate.order_id = this.data.goods.o_id evaluate = Object.assign(&#123;&#125;, evaluate) this.$http.post(this.evaluateUrl,&#123;no:this.data.goods.o_orderno,evaluate:evaluate&#125;).then(response =&gt; &#123; if(response.data.status === 200)&#123; //重新拉取数据 this.$http.get(location.href).then(function(response)&#123; if(response.data.status === 200)&#123; this.$message(&#123; message:'评价成功!', type:'success' &#125;) //重新拉取数据 this.data = response.data.data &#125; &#125;).catch(e =&gt; &#123;&#125;) &#125;else&#123; this.$message(&#123; message:response.data.message, type:'error' &#125;) &#125; &#125;).catch(e =&gt; &#123;&#125;) &#125; &#125;&#125;) 至此,经过测试,解决了同一页面多个upload组件上传预览并分别异步提交对应表单到后台的问题]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps使用google的bbr脚本加速]]></title>
    <url>%2F2018%2F06%2F06%2Fvps%E4%BD%BF%E7%94%A8google%E7%9A%84bbr%E8%84%9A%E6%9C%AC%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[问题从去年开始用vultr的vps,先是搭建了ssserver,然后各种web服务,以一个nginx为代理服务器,代理本地不同端口的各种服务,总体来说,vultr家的vps体验很好,除了一点:速度较慢,尤其是晚上8-11点(我买的是东京节点),之前在google上看了很久关于vps加速的方案,基本都是通过锐速,kcptun较多 锐速:国产软件,收费,且不开源,不开源,意味着可能被监控,所以直接pass kcptun:个人觉得麻烦,server端配了还要配client最后:当时没发现google的bbr,于是将就用着,也还行,就是偶尔想看看youtube的时候只能看480p的,还卡的厉害…直到前几天,无意中看到google的tcp-bbr拥塞控制技术…参考链接 配置 确认VPS的虚拟化技术不为Openvz(vultr的服务器都不是OpenvzO(∩_∩)O哈哈~) 下载脚本wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 查看脚本支持的系统版本(支持内核版本大于4.9的系统),cat ./bbr.sh在脚本开始的注释中包含以下信息:1System Required: CentOS 6+, Debian7+, Ubuntu12+ 我当前的vps是Ubuntu 18.04 LTS,因此满足开启tcp_bbr的条件 赋予执行权限:chmod +x ./bbr.sh 执行:./bbr.sh 完成后使用lsmod | grep tcp_bbr查看tcp_bbr加速模块是否已经安装成功 重启vps:reboot 效果直接看YouTube的1080P视频吧,最直观,直接上图全程无卡顿]]></content>
      <tags>
        <tag>google</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitlab出现forbidden的解决方法]]></title>
    <url>%2F2018%2F06%2F06%2Fgitlab%E5%87%BA%E7%8E%B0forbidden%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题前些天在公司的测试服务器上基于docker安装了gitlab,今天同事突然反映gitlab地址访问的时候页面提示Forbidden,http状态码也是对应的403,于是google一下,发现原因可能是较多的并发导致的访问被拒绝 原因 Gitlab使用rack_attack做了并发访问的限制 解决方法配置/etc/gitlab/gitlab.rb文件,服务器当前使用的docker,对应目录是/home/gitlab/config/gitlab.rb(该目录/文件根据docker容器创建时指定的目录/文件映射关系决定) 找到下面这段配置1234567gitlab_rails['rack_attack_git_basic_auth'] = &#123; 'enabled' =&gt; true, 'ip_whitelist' =&gt; ["127.0.0.1", "服务器公网ip"], 'maxretry' =&gt; 10, 'findtime' =&gt; 60, 'bantime' =&gt; 3600&#125; 去掉注释,然后改为1234567gitlab_rails['rack_attack_git_basic_auth'] = &#123; 'enabled' =&gt; true, 'ip_whitelist' =&gt; ["127.0.0.1", "服务器公网ip"], 'maxretry' =&gt; 100, 'findtime' =&gt; 60, 'bantime' =&gt; 60&#125; 保存退出 运行docker exec 容器名称 gitlab-ctl reconfigure至此,上述问题解决 参考链接:GitLab issuing temporary IP bans - 403 forbidden]]></content>
      <tags>
        <tag>docker</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker搭建gitlab和svn服务]]></title>
    <url>%2F2018%2F05%2F21%2Fdocker%E6%90%AD%E5%BB%BAgitlab%E5%92%8Csvn%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[之前公司里的代码都是托管到局域网服务器上的,现在由于部分同事远程办公的需要,计划把git和svn都转到公网的centos服务器上去,但是gitlab的配置是真心费时间,所以决定用docker来做这个事情,以下是一些步骤和总结 使用daocloud给docker加个速先…可以通过这个链接里面的命令给docker改个源,不然速度慢死… gitlab安装 拉取镜像 1docker pull gitlab/gitlab-ce:latest 新建授权用户 1useradd -d /home/gitlab -s /bin/sh -m gitlab 后台运行容器,指定域名,端口映射关系,目录映射关系,将容器命名为gitlab,方便后续操作 123456789docker run --detach \ --hostname git.vcs.trycheers.com \ --publish 10443:443 --publish 10080:80 --publish 10022:22 \ --name gitlab \ --restart always \ --volume /home/gitlab/config:/etc/gitlab \ --volume /home/gitlab/logs:/var/log/gitlab \ --volume /home/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest 用apache对10080端口进行反代,使之能够通过域名访问 123456&lt;VirtualHost *:80&gt; ServerName hostname ProxyPreserveHost On ProxyPass / http://localhost:10080/ ProxyPassReverse / http://localhost:10080/&lt;/VirtualHost&gt; svn安装 后台运行容器,指定端口映射关系,目录映射关系,将容器命名为svn,方便后续操作 1docker run -d -p 9200:80 -p 9201:443 -v /home/subversion/svn:/var/local/svn -v /home/subversion/svn_backup:/var/svn-backup -v /home/subversion/svn_conf/:/etc/apache2/dav_svn/ --name svn marvambass/subversion 添加svn用户 1htdigest /home/subversion/svn_conf/dav_svn.passwd Subversion username 修改仓库/分组/用户权限直接编辑/home/subversion/svn_conf/dav_svn.authz 用apache对9200端口进行反代,使之能够通过域名访问 123456&lt;VirtualHost *:80&gt; ServerName hostname ProxyPreserveHost On ProxyPass / http://localhost:9200/ ProxyPassReverse / http://localhost:9200/&lt;/VirtualHost&gt; 关于gitlab的系统资源占用看图说话在docker中常驻内存大概是2GB+,cpu开销通常只是在启动时候特别大,因此要运行gitlab推荐至少使用2核4GB的服务器配置! 哎,也难怪当时折腾半天也没能在我家树莓派(arm架构的4核cpu,512M内存…)上搞定gitlab… 总结gitlab在刚启动时会加载大量的环境依赖,因此可能出现cpu占用高的情况,根据服务器性能不同会持续一段时间,通常在cpu占用降至正常时才能访问到本地的gitlab项目]]></content>
      <tags>
        <tag>docker</tag>
        <tag>gitlab</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派玩耍记]]></title>
    <url>%2F2018%2F04%2F14%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%8E%A9%E8%80%8D%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这篇文章是自己入手树莓派之后的一些使用记录前些天看 v2ex 上有人讨论树莓派，于是出于好奇在淘宝上淘了一只树莓派来玩玩 体积超级小… 一个板子,一个塑料盒子装上完工 刚开始的时候尝试了一下官方的NOOBS工具安装raspbian系统,这个系统是为树莓派定制的基于Debian的 linux 系统,但不知什么原因总是间歇性卡死,加之个人偏好 ubuntu 一点,于是安装了Ubuntu_MATE 系统安装基本步骤: 下载系统镜像 将下载的ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img镜像解压后使用dd命令将镜像写入到 sd 卡中(我的环境为 macOS),注意写入完成后一定要使用unmount将 sd 卡推出,然后拔出 sd 卡 将 sd 卡插入树莓派,并连接好所有外设后开机,然后像安装 QQ 一样完成了Ubuntu_MATE的安装过程 简易播报系统: 当时冒出一个想法:写一个每天定时播放未来两天天气预报的小程序(非彼小程序),涉及的功能点:天气预报接口;一个基于轻量级的 api 框架实现的 api;一个定时任务;一个文字转语音脚本;一个音频文件播放器;当然还需要一个外接小音箱… 于是安装了 lnmp 环境(当下没有用到 mysql),mplayer,git,文字转音频使用的百度sdk(php),通过 git 安装了lumen 接口开发 路由 1$router-&gt;get('/get_weather','WeatherController@getWeather'); 控制器WeatherController.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpnamespace App\Http\Controllers;use GuzzleHttp\Client;use Illuminate\Support\Facades\Cache;class WeatherController extends Controller&#123; /** * Create a new controller instance. * * @return void */ public function __construct() &#123; // &#125; //基于树莓派的简易天气预报系统 public function getWeather() &#123; //获取天气信息 $client = new Client(); // 实例化 $city = '成都'; $city_code = urlencode($city); $aqi = [ '好', '中等', '不适于敏感人群', '不健康', '非常不健康', '危险', ]; if (Cache::has('report') === false) &#123; $url = 'https://www.sojson.com/open/api/weather/json.shtml?city=' . $city_code; // 设置一个可访问的 url $http = $client-&gt;request('GET', $url); // 执行 // 判断 http 状态码为 200 的时候，执行成功 $aqi_content = '未知'; if ($http-&gt;getStatusCode() == 200) &#123; $weather = json_decode($http-&gt;getBody()-&gt;getContents(), true); if ($weather['data']['forecast'][0]['aqi'] &lt;= 50) &#123; $aqi_content = $aqi[0]; &#125; else if ($weather['data']['forecast'][0]['aqi'] &lt;= 100) &#123; $aqi_content = $aqi[1]; &#125; else if ($weather['data']['forecast'][0]['aqi'] &lt;= 150) &#123; $aqi_content = $aqi[2]; &#125; else if ($weather['data']['forecast'][0]['aqi'] &lt;= 200) &#123; $aqi_content = $aqi[3]; &#125; else if ($weather['data']['forecast'][0]['aqi'] &lt;= 300) &#123; $aqi_content = $aqi[4]; &#125; else if ($weather['data']['forecast'][0]['aqi'] &lt;= 500) &#123; $aqi_content = $aqi[5]; &#125; else &#123; &#125; //拼装字符串 $report = '现在预报,' . $city . '未来两天天气情况,' . $city . ',' . date('Y年m月', time()) . $weather['data']['forecast'][1]['date'] . ',天气情况,' . $weather['data']['forecast'][1]['high'] . ',' . $weather['data']['forecast'][1]['low'] . ',' . $weather['data']['forecast'][1]['type'] . ',' . $weather['data']['forecast'][1]['fx'] . ',风力,' . $weather['data']['forecast'][1]['fl'] . ',日出时间,' . $weather['data']['forecast'][1]['sunrise'] . ',日落时间,' . $weather['data']['forecast'][1]['sunset'] . ',空气污染指数,' . $aqi_content; $report .= ',' . $city . ',' . date('Y年m月', time()) . $weather['data']['forecast'][2]['date'] . ',天气情况,' . $weather['data']['forecast'][2]['high'] . ',' . $weather['data']['forecast'][2]['low'] . ',' . $weather['data']['forecast'][2]['type'] . ',' . $weather['data']['forecast'][2]['fx'] . ',风力,' . $weather['data']['forecast'][2]['fl'] . ',日出时间,' . $weather['data']['forecast'][2]['sunrise'] . ',日落时间,' . $weather['data']['forecast'][2]['sunset'] . ',空气污染指数,' . $aqi_content; Cache::add('report', $report, 60); &#125; &#125; $report = Cache::get('report'); generate_audio($report); &#125;&#125; 以上的generate_audio()即是自行封装后的百度的文字转语音sdk 定时任务 创建一个目录/data/weather_reports/用于保存mp3临时文件 crontab -e添加定时任务130 19 * * * curl http://localhost/get_weather &amp;&amp; /usr/bin/mplayer /data/weather_reports/weather_forecast.mp3 &gt; /dev/null 2&gt;&amp;1 以上是每天19点30分使用curl命令请求本地的api并使用mplayer打开位于/data/weather_reports/目录的weather_forecast.mp3文件,并将标准输出&amp;错误输出重定向到空文件中 简易播报系统完成至此,一个定时播报小程序已完成,同时还可以利用内网穿透开放公网对该树莓派的ssh访问,实现远程遥控播放😋为了进一步方便操作(因为除了第一次安装系统,其他时候都希望直接通过命令行操作树莓派而不是外接一个显示器,资源有限…),将frp客户端的连接命令加入了开机启动 开机启动步骤 在frp客户端所在目录新建sh文件frp_start.sh文件,并赋予执行权限 12touch ./frp_start.shchmod +x ./frp_start.sh 写入命令 123456789101112#!/bin/bash### BEGIN INIT INFO# Provides: lestat# Required-Start: $local_fs $network# Required-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: start frp service# Description: start frp service### END INIT INFOcd frp客户端所在目录nohup ./frpc -c ./frpc.ini &amp; 将文件连接到/etc/init.d/目录 1ln -s frp客户端所在目录/frp_start.sh /etc/init.d/frp_start 在/etc/init.d/使用update-rc.d命令进行配置 1sudo update-rc.d frp_start defaults 99 配置成功后可以在/etc/rc[对应的系统运行级别].d/目录中看到frp_start 未完待续…]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于mysql查询语句的一次问题记录]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%85%B3%E4%BA%8Emysql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%80%E6%AC%A1%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近在开发一个公司内部使用的财务报表系统,在一次查询时数据库报了一个错误,在网上查看原因并解决问题之后顺便记录一下,该sql的目标是从日报主表,日报月数据表,日报模块表中查询到指定经营公司,指定日期的当日汇总数据(包含部分当月数据用于后续计算) 问题sql如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263SELECT A1.depcode AS depcode, SUM(d_dd_xcddsntq) AS sntq, ( SELECT ( SUM(d_jk_scddldl) + SUM(d_jk_zcddldl) + SUM(d_jk_hdjkl) ) AS bysj FROM mall_daily A LEFT JOIN mall_daily_jk B ON A.id = B.d_id LEFT JOIN mall_daily_month C ON A.depcode = C.depcode AND A.d_datetime &gt;= C. START AND A.d_datetime &lt;= C. END WHERE A.d_date &gt;= DATE_FORMAT('2018-03-01', '%Y-%m-%d') AND A.d_date &lt;= DATE_FORMAT('2018-03-21', '%Y-%m-%d') AND A.depcode = A1.depcode ) AS aj13, ( SELECT SUM(B.d_dd_xcztdd) AS bysj FROM mall_daily A LEFT JOIN mall_daily_dd B ON A.id = B.d_id LEFT JOIN mall_daily_month C ON A.depcode = C.depcode AND A.d_datetime &gt;= C. START AND A.d_datetime &lt;= C. END WHERE A.d_date &gt;= DATE_FORMAT('2018-03-01', '%Y-%m-%d') AND A.d_date &lt;= DATE_FORMAT('2018-03-21', '%Y-%m-%d') AND C.table_name = 'DailyDd' AND A.depcode = A1.depcode ) AS aj25, TRUNCATE ( (SELECT aj25) / (SELECT aj13), 2 ) AS bysj, D.d_month_byjh AS byjh, TRUNCATE ( (SELECT bysj) / (SELECT byjh), 2 ) AS jhdcl, TRUNCATE (30 / 31, 2) AS sjjd, TRUNCATE ( (SELECT bysj) / (SELECT sntq), 2 ) AS tbFROM mall_daily A1LEFT JOIN mall_daily_dd B ON A1.id = B.d_idLEFT JOIN mall_daily_jk C ON A1.id = C.d_idLEFT JOIN mall_daily_month D ON A1.depcode = D.depcodeAND A1.d_datetime &gt;= D. STARTAND A1.d_datetime &lt;= D.ENDWHERE A1.d_date &gt;= DATE_FORMAT('2018-03-01', '%Y-%m-%d')AND A1.d_date &lt;= DATE_FORMAT('2018-03-21', '%Y-%m-%d')GROUP BY A1.depcode; 上述sql在执行时提示1[Err] 1247 - Reference 'sntq' not supported (reference to group function) 大意是不支持’sntq’的引用,但是上面SELECT的字段中明明有这个alias。后来临时通过在这个位置用表达式替换了别名解决(将SELECT sntq替换为SUM(d_dd_xcddsntq)),但始终觉得不完美,最后google以下找到了更好的解决方式,就是在这个查询语句外层再套一层查询语句,也就是将当前查询语句作为另一个语句的子查询,修改后结构如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970SELECT depcode, sntq, bysj, byjh, jhdcl, sjjd, TRUNCATE (bysj / sntq, 2) AS tbFROM ( SELECT A1.depcode AS depcode, SUM(d_dd_xcddsntq) AS sntq, ( SELECT ( SUM(d_jk_scddldl) + SUM(d_jk_zcddldl) + SUM(d_jk_hdjkl) ) AS bysj FROM mall_daily A LEFT JOIN mall_daily_jk B ON A.id = B.d_id LEFT JOIN mall_daily_month C ON A.depcode = C.depcode AND A.d_datetime &gt;= C. START AND A.d_datetime &lt;= C. END WHERE A.d_date &gt;= DATE_FORMAT('2018-03-01', '%Y-%m-%d') AND A.d_date &lt;= DATE_FORMAT('2018-03-21', '%Y-%m-%d') AND A.depcode = A1.depcode ) AS aj13, ( SELECT SUM(B.d_dd_xcztdd) AS bysj FROM mall_daily A LEFT JOIN mall_daily_dd B ON A.id = B.d_id LEFT JOIN mall_daily_month C ON A.depcode = C.depcode AND A.d_datetime &gt;= C. START AND A.d_datetime &lt;= C. END WHERE A.d_date &gt;= DATE_FORMAT('2018-03-01', '%Y-%m-%d') AND A.d_date &lt;= DATE_FORMAT('2018-03-21', '%Y-%m-%d') AND C.table_name = 'DailyDd' AND A.depcode = A1.depcode ) AS aj25, TRUNCATE ( (SELECT aj25) / (SELECT aj13), 2 ) AS bysj, D.d_month_byjh AS byjh, TRUNCATE ( (SELECT bysj) / (SELECT byjh), 2 ) AS jhdcl, TRUNCATE (30 / 31, 2) AS sjjd FROM mall_daily A1 LEFT JOIN mall_daily_dd B ON A1.id = B.d_id LEFT JOIN mall_daily_jk C ON A1.id = C.d_id LEFT JOIN mall_daily_month D ON A1.depcode = D.depcode AND A1.d_datetime &gt;= D. START AND A1.d_datetime &lt;= D. END WHERE A1.d_date &gt;= DATE_FORMAT('2018-03-01', '%Y-%m-%d') AND A1.d_date &lt;= DATE_FORMAT('2018-03-21', '%Y-%m-%d') GROUP BY A1.depcode ) t; 参考链接]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp+nginx实现内网穿透]]></title>
    <url>%2F2018%2F03%2F26%2Ffrp%2Bnginx%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[写在前面:上一篇文章写了关于ngrok+nginx实现内网穿透的流程,并提出了一些存在的问题,昨天试过frp之后,将之前ngrok存在的无法映射本地域名的问题解决了 frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 先决条件有一个域名,并解析到自己服务器上,如:*.frp.lestat.me有一个具备固定ip的公网服务器 系统环境假设环境为:服务器OS:ubuntu17.10客户端OS:macOS High Sierra以下内容将按照上述环境进行搭建 部署相对于ngrok还需要编译源码,frp方便很多,真正的开箱即用 服务器 下载对应操作系统的frp服务端&amp;客户端至服务器和内网电脑 12wgethttps://github.com/fatedier/frp/releases/download/v0.16.1/frp_0.16.1_linux_amd64.tar.gz 解压 123tar zxf ./frp_0.16.1_linux_amd64.tar.gzcd ./frp_0.16.1_linux_amd64ll 目录结构如下(不同版本可能有差异,但大致相似): 12345678910-rw-rw-r-- 1 kcptun kcptun 11358 Mar 21 10:11 LICENSE-rwxrwxr-x 1 kcptun kcptun 6154432 Mar 21 10:10 frpc*-rw-rw-r-- 1 kcptun kcptun 126 Mar 21 10:11 frpc.ini-rw-rw-r-- 1 kcptun kcptun 5306 Mar 21 10:11 frpc_full.ini-rwxrwxr-x 1 kcptun kcptun 7586848 Mar 21 10:10 frps*-r--r----- 1 root root 11207 Mar 25 15:38 frps.2018-03-25.log-rw-rw-r-- 1 kcptun kcptun 2127 Mar 25 13:42 frps.ini-rw-rw---- 1 root root 723 Mar 26 05:06 frps.log-rw-rw-r-- 1 kcptun kcptun 2300 Mar 21 10:11 frps_full.ini-rw------- 1 root root 0 Mar 25 11:12 nohup.out 编辑配置文件 vim ./frps.ini 可参考如下配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 服务器端监听客户端连接请求的端口bind_port = 7000# 服务器端监听http请求的端口(由于80端口被nginx占用,因此指定其他端口)vhost_http_port = 8080# 服务器用以显示连接状态的站点端口,以下配置中可以通过访问IP:7500登录查看frp服务端状态等信息dashboard_addr = 0.0.0.0dashboard_port = 7500# dashboard对应的用户名/密码dashboard_user = userdashboard_pwd = pwd# 日志文件路径log_file = ./frps.log# 日志记录错误级别,分为:trace, debug, info, warn, errorlog_level = warn# 日志保存最大天数log_max_days = 3# 客户端连接校验码(客户端需与之相同)privilege_token = privilege_token# heartbeat configure, it's not recommended to modify the default value# the default value of heartbeat_timeout is 90# heartbeat_timeout = 90# only allow frpc to bind ports you list, if you set nothing, there won't be any limit# privilege_allow_ports = 2000-3000,3001,3003,4000-50000# pool_count in each proxy will change to max_pool_count if they exceed the maximum valuemax_pool_count = 5# max ports can be used for each client, default value is 0 means no limitmax_ports_per_client = 0# authentication_timeout means the timeout interval (seconds) when the frpc connects frps# if authentication_timeout is zero, the time is not verified, default is 900sauthentication_timeout = 900# 支持外部访问的域名(需要将域名解析到IP)subdomain_host = frps.lestat.me 配置nginx反向代理,将来自80端口并指向*.frp.lestat.me的请求分发至frp服务器http请求的监听端口 12345678910111213141516171819202122server &#123; listen 80; server_name *.frps.lestat.me; location / &#123; proxy_pass http://127.0.0.1:8080; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_max_temp_file_size 0; proxy_redirect off; proxy_read_timeout 240s; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 启动frp服务器并后台运行,启动完成后可通过lsof -i :7000查看端口占用情况 1nohup ./frps -c ./frps.ini &amp; 客户端 创建目录并解压 编辑配置文件 123456789[common]server_addr = 服务器IPserver_port = 7000privilege_token = privilege_tokenauth_token = auth_token[hccrm]type = httplocal_port = 80subdomain = hccrm 启动frp客户端程序 1./frpc -c ./frpc.ini 本地apache/nginx虚拟主机配置域名别名(alias),根据自己环境而定 流程图解假设甲使用的浏览器希望访问乙所在内网环境服务器的web项目: 最后尝试使用*.frps.lestat.me访问站点看是否正常,相比ngrok的流程,frp省去了编译,少踩不少坑,的确省事多了]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok+nginx实现内网穿透]]></title>
    <url>%2F2018%2F03%2F24%2Fngrok%2Bnginx%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[写在前面:前天在qq群里看到有人在讨论替代花生壳的工具，说到了ngrok，说是可以实现花生壳一样的内网穿透，个人认为主要有以下几个用处: 可以在公司测试服务器上搭建一个服务,实现测试站点的本地访问(公网访问本地服务器)，在这之前通常是上传网站到服务器并解析一个子域名，相对比较费时 微信接口开发的时候优势更明显，因为微信的OAuth一类认证需要一个公网域名且端口必须是80/443(也是本文需要用到nginx做反向代理的原因之一) 欢迎补充… ngrok1.x介绍(2.x没有开源官网)ngrok1.x源码github地址如上封面图所示 橘色屏幕的笔记本是你的工作机器，安装了ngrok客户端ngrok.com所在的服务器安装了ngrok的服务端（ngrokd）利用ngrok 8080命令可以将你本机的8080端口暴露给反向代理至ngrok.com的某个二级域名如：.ngrok.com公网用户可以通过.ngrok.com就可以访问你本机8080端口上的站点内容了。由此可见，借助ngrok，可以解决web项目(尤其是微信接口相关)开发过程经常遇到的“本地开发，外网调试”问题。 先决条件 有一个域名,并解析到自己服务器上,如:*.ngrok.lestat.me 有一个具备固定ip的公网服务器 部署 基本步骤:安装go环境-&gt;下载ngrok源码-&gt;使用go编译ngrok以及相关环境变量的设置-&gt;证书配置-&gt;运行ngrok服务器端并指定监听的http/https端口-&gt;nginx配置文件中对上一步中相关端口做反向代理配置-&gt;重启nginx-&gt;生成对应OS(linux,darwin,windows)的客户端-&gt;本地机器下载上一步生成的客户端-&gt;本地新建配置文件ngrok.cfg-&gt;本地运行客户端并指定配置文件-&gt;出现online则说明穿透成功 一个例子数据准备本机地址 IP：127.0.0.1，HTTP 为 80外网地址 IP：45.77.14.6，HTTP 为 80(NGINX监听该端口,并对.ngrok.lestat.me域名进行转发到服务器的60端口)域名为：http://.ngrok.lestat.me 预期结果外网访问 http://*.ngrok.lestat.me可以访问到本机上80端口提供的网站下文按照前面的例子来搭建 Go环境的安装 下载并解压GOLANG 12wget -c https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gztar -C /usr/local -zxvf go1.8.3.linux-amd64.tar.gz 设置相关环境变量 1234export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/binexport GOPATH=$HOME/goexport GOROOT_BOOTSTRAP=/usr/local/go 检查安装是否成功go version 安装ngrok 下载并配置参数 12345cd /usr/local/git clone https://github.com/inconshreveable/ngrok.gitexport GOPATH=/usr/local/ngrok/export NGROK_DOMAIN="ngrok.lestat.me"cd ngrok 生成证书 12345openssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pemopenssl genrsa -out server.key 2048openssl req -new -key server.key -subj "/CN=$NGROK_DOMAIN" -out server.csropenssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 5000 将源码下的证书复制到指定位置 123cp rootCA.pem assets/client/tls/ngrokroot.crtcp server.crt assets/server/tls/snakeoil.crtcp server.key assets/server/tls/snakeoil.key 编译服务器&amp;客户端(linux64位),如果是32位系统则是amd386 1234cd /usr/local/go/srcGOOS=linux GOARCH=amd64 ./make.bashcd /usr/local/ngrok/GOOS=linux GOARCH=amd64 make release-server release-client 编译Mac64位客户端1234cd /usr/local/go/srcGOOS=darwin GOARCH=amd64 ./make.bashcd /usr/local/ngrok/GOOS=darwin GOARCH=amd64 make release-client 编译Windows64位客户端1234cd /usr/local/go/srcGOOS=windows GOARCH=amd64 ./make.bashcd /usr/local/ngrok/GOOS=windows GOARCH=amd64 make release-client 服务端运行 进入到ngrok的bin目录下 12cd /usr/local/ngrok/bin./ngrokd -domain="$NGROK_DOMAIN" -httpAddr=":60" -httpsAddr=":63" 如果出现如下提示,说明服务端开启成功 12345[06:59:42 UTC 2018/03/24] [INFO] (ngrok/log.(*PrefixLogger).Info:83) [registry] [tun] No affinity cache specified[06:59:42 UTC 2018/03/24] [INFO] (ngrok/log.Info:112) Listening for public http connections on [::]:60[06:59:42 UTC 2018/03/24] [INFO] (ngrok/log.Info:112) Listening for public https connections on [::]:63[06:59:42 UTC 2018/03/24] [INFO] (ngrok/log.Info:112) Listening for control and proxy connections on [::]:4443[06:59:42 UTC 2018/03/24] [INFO] (ngrok/log.(*PrefixLogger).Info:83) [metrics] Reporting every 30 seconds 客户端运行与使用mac 客户端的位置：1/usr/local/ngrok/bin/darwin_amd64/ngrok windows 客户端的位置：1/usr/local/ngrok/bin/windows_amd64/ngrok.exe linux 客户端的位置：1/usr/local/ngrok/bin/ngrok 新建ngrok.cfg文件(配置文件)1234567891011server_addr: "ngrok.lestat.me:4443"trust_host_root_certs: falsetunnels: #可定义多个域名 test1: subdomain: "test1" #定义服务器分配域名前缀 proto: http: 80 #映射端口，不加ip默认本机 test2: subdomain: "test2" #定义服务器分配域名前缀 proto: http: 81 #映射端口，不加ip默认本机 从命令行运行客户端文件,如下:方法1:1./ngrok -config=ngrok.cfg -log=ngrok.log start test1 方法2:(最后一个8080代表映射的本地主机端口)1./ngrok -config=ngrok.cfg -log=ngrok.log -subdomain=test1 8080 如果返回相似于以下的内容,说明客户端启动成功1234567Tunnel Status online Version 1.7/1.7 Forwarding https://hccrm.ngrok.lestat.me:60 -&gt; 127.0.0.1:80 Forwarding http://hccrm.ngrok.lestat.me:60 -&gt; 127.0.0.1:80 Web Interface 127.0.0.1:4040 # Conn 0 Avg Conn Time 0.00ms nginx反向代理相关配置假设: ngrok监听http的端口为60 nginx监听了当前服务器的80端口(域名访问hccrm.ngrok.lestat.me时会直接访问到nginx监听的80端口,因此需要nginx转发)123456789101112131415161718server &#123; listen 80; server_name *.ngrok.lestat.me; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host:60; #此处端口要跟 启动服务端ngrok 时指定的端口一致 proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection ""; proxy_pass http://127.0.0.1:60; # 反向代理对应的本地ip:port &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 重启nginxservice nginx reload 至此,已实现了内网穿透目前存在的问题: 目前不知如何实现对本地虚拟主机的访问(例如本地apache上httpd-vhosts中配置的虚拟主机) 由于ngrok1.x已于两年前停止维护,再加上第一个问题1,因此后续准备写一篇关于frp的搭建记录,这是一个长期维护的开源项目,值得学习!]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈shadowsocks中的pac配置]]></title>
    <url>%2F2018%2F02%2F14%2F%E6%B5%85%E8%B0%88shadowsocks%E4%B8%AD%E7%9A%84pac%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[大概是从去年开始使用的shadowsocks实现科学上网,当时在配置完代理服务器之后能够用了就没管其他的配置。直到最近想在维基百科上注册一个账号的时候发现由于一些原因,当前使用代理的ip被封禁了由于GFW是通过dns污染的方式屏蔽了zh.wikipedia.org(其他语言的wikipedia其实是可以在国内直接访问的比如英文站),这个问题可以通过关闭代理并修改hosts文件解决,但这样太麻烦,因为需要定期更新hosts文件的ip地址,后来google了一下发现shadowsocks里面有一个名为pac的文件,这个文件的域名列表来自于GFWlist,而正是这个文件决定了shadowsocks处于pac模式时哪些域名需要被代理,在这个文件之外的域名都会直接访问。因此,解决维基的ip封禁且要继续使用代理上网只需要2个步骤 修改本地hosts为wikipedia中文当前的ip(解决dns污染) 修改pac文件中的配置,将wikipedia.org相关的配置去掉即可 PAC的优势PAC自动代理属于智能判断模式，相比全局代理，它的优点有： 不影响国内网站的访问速度，防止无意义的绕路 节省Shadowsocks服务的流量，节省服务器资源 控制方便]]></content>
  </entry>
  <entry>
    <title><![CDATA[近期工作中的收获]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%BF%91%E6%9C%9F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E6%94%B6%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[眼下快要过年了,手头的项目也终于接近尾声,抽点时间来记录下近段时间的工作心得前段时间在工作之余我抽空看了一些ECMA6的语法,简单学习了一下webpack,了解了babel,后面也尝试着使用vue-cli搭建自己的demo并熟悉其中的结构 说说最近做的一个项目:一个接口开发(前端)项目,接口由客户提供(java开发,json数据格式),我方负责移动端web开发和后台页面的开发,并调试好所有接口(后端接口情况:权限相关[14],会员模块[10],片库[14],,出品[19],媒体[15],资讯[11],直通车[14],ip活动[12],营销联盟[13])刚拿到需求的时候我还是比较担心能否搞定,毕竟作为一个phper之前的确没有搞过spa的开发,但之前做了那么多spa的功课,也觉得是时候真正的实践一下了,于是很快找到了一个基于vue+elementui的后台框架vue-element-admin,据我最近观察,这个项目在github上每天平均增加将近100个star… 这个框架替我们完成了很多基本方法的封装,路由访问权限,页眉标签切换,常用的各种表格,表单等;开发起来效率相对较高,在我后来实际的开发中也应证了这点最后花了两周时间,搭建了一个小型后台管理系统并完成所有接口的调试使用vue做开发的感觉就是代码比曾经用jq的项目更规范(也可能是因为框架中引入了eslint,配合vscode的eslint+prettier一键格式化,实现简单操作就能遵循eslint代码规范);由于vue-cli已经将webpack,babel打包好,并且实现了ctrl+s自动刷新页面预览且不会清空console里面的内容,开发的体验变得非常好。强烈推荐chrome的Vue DevTools插件,安装完成后可以在chrome右上方看到vue的logo,在dev模式下的页面可以直接看到开发者工具的标签栏多出一个Vue标签,点击即可查看到当前页面的信息! 目前为止,自己对vue的了解还不够深入,对vuex,组件的使用还不够灵活,还需要更多的实践 新的一年,继续加油!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue开发中的一些总结]]></title>
    <url>%2F2018%2F01%2F26%2FVue%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[关于axios的使用细节基于vue做spa开发,个人很多时候使用的请求扩展是axios,这个扩展会把常用的请求封装好发送出去,使用的时候只需要传参数即可。今天遇到的一个问题是后端接口接收get方式传参,我这边有一个数组需要通过get方式传递过去,假设数组名称是:ids,请求中默认就是ids[]的形式,接口需要提供ids的形式,此时需要引入qs扩展,并在请求位置添加一项配置,以转换参数格式,示例代码如下:1234567891011121314/** todo :会员审核列表的通过与驳回(批量和单个为同一个方法), 需要管理员登陆* @param data object* */export function userInfoCheck(data) &#123; return request(&#123; url: '/backend/userInfoCheck', method: 'get', params: data, paramsSerializer: function(params) &#123; return qs.stringify(params, &#123; arrayFormat: 'repeat' &#125;) &#125; &#125;)&#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vue中$nextTick的一点使用心得]]></title>
    <url>%2F2018%2F01%2F24%2Fvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[当下公司在做一个媒体门户网站,后台由另一家公司使用java开发并提供接口,本人负责开发后台页面,使用的是vue-element-admin开发下面说一下问题场景,在开发过程中有一个后台管理员角色页面,其中包含一个表单dialog,在其中使用了el-tree组件,相关 代码结构如下:12345678910111213&lt;div class="filter-container"&gt; &lt;el-button class="filter-item" style="margin-left: 10px;" v-waves @click="handleCreate" type="primary" icon="el-icon-edit"&gt;新增角色 &lt;/el-button&gt;&lt;/div&gt;&lt;el-dialog :title="textMap[dialogStatus]" :visible.sync="dialogFormVisible" width="50%"&gt; &lt;el-form :rules="rules" ref="dataForm" :model="temp" label-position="top" label-width="90px" style='width: 400px; margin-left:50px;'&gt; &lt;el-form-item label="选择权限" prop="sysPermission"&gt; &lt;el-tree ref="tree" :data="sysPermission" :props="formProps" show-checkbox @check-change="handleCheckChange" node-key="id"&gt;&lt;/el-tree&gt; &lt;/el-form-item&gt; &lt;/el-form&gt;&lt;/el-dialog&gt; 相关的js如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687export default &#123; name: 'sysRoleList', data() &#123; return &#123; tableKey: 0, list: null, total: null, listLoading: true, formLoading: true, listQuery: &#123; page: 1, limit: 20, importance: undefined, title: undefined, type: undefined, sort: '+id' &#125;, dialogFormVisible: false, dialogStatus: 'update', textMap: &#123; update: '编辑角色', create: '新增角色' &#125;, rules: &#123; sysRoleName: [&#123;required: true, message: '必须填写角色名称', trigger: 'blur'&#125;] &#125;, // 表单数据 temp: &#123; id: '', sysPermissionList: [], sysRoleName: '' &#125;, currentKeys: [], // 表单权限字段映射 formProps: &#123; label: 'sysPermissionName' &#125;, sysPermission: &#123;&#125; &#125; &#125;, created() &#123; // 列表数据 // this.getList() // 获取所有权限 // this.findAllSysPermission() &#125;, methods: &#123; /* * todo:checkbox状态变更监听 * */ handleCheckChange(data, checked, indeterminate) &#123; const idObj = &#123;id: data.id&#125; this.temp.sysPermissionList.push(idObj) &#125;, resetTemp() &#123; this.temp = &#123; id: '', sysRoleName: '', sysPermissionList: [] &#125; &#125;, handleCreate() &#123; this.resetTemp() this.dialogStatus = 'create' this.currentKeys = [] this.dialogFormVisible = true this.$nextTick(() =&gt; &#123; this.$refs['dataForm'].clearValidate() this.$refs.tree.setCheckedKeys(this.currentKeys) &#125;) &#125;, handleUpdate(row) &#123; this.resetTemp() this.dialogStatus = 'update' this.dialogFormVisible = true this.temp = Object.assign(&#123;&#125;, row) // copy obj this.currentKeys = [] row.sysPermissionList.forEach((value, index) =&gt; &#123; this.currentKeys.push(value[0]) &#125;) this.$nextTick(() =&gt; &#123; this.$refs['dataForm'].clearValidate() this.$refs.tree.setCheckedKeys(this.currentKeys) &#125;) &#125; &#125; &#125; 需求:需要在每次编辑数据的时候触发&lt;el-tree&gt;的方法setCheckedKeys问题:之前没有把this.$refs.tree.setCheckedKeys()写在this.$nextTick的callback之中,因此会提示:1TypeError: Cannot read property 'setCheckedKeys' of undefined 解决方法:把dialog组件内的其他需要执行方法的组件方法写到this.$nextTick的callback之中原因如下(官方): 可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。深入响应式原理 个人理解:vue这么做是因为频繁的更新dom是特别耗费性能的，所以搞了一个批处理更新，把所有的update操作放到任务队列中，等主线程中执行栈的所有同步任务执行完毕，系统就会读取任务队列一个比较典型的场景，created回调里是无法直接通过this.$refs获取到用ref命名的子组件的，只有通过$nextTick才能访问到。还有比如dialog里有一个步骤条组件，在每次打开对话框都想触发步骤1的动作。如果直接写step=0;step=1;是不会有变化的，因为整个函数执行完之前DOM都不会刷新。把step=1放到$nextTick里就可以了]]></content>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[certbot+letsencrypt配置免费单证书多域名ssl证书]]></title>
    <url>%2F2018%2F01%2F03%2Fcertbot-letsencrypt%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[前些天看到微信公众平台官方公告关于公众平台接口不再支持HTTP方式调用的公告之后决定把项目的协议从http改成https,于是开始在网上查,完成之后总结了一点经验 本文演示的是通用证书,即在certbot命令中不需要指定--apache或者--nginx之类,只需要在完成证书生成之后在服务器配置文件里进行引用即可 Let’s EncryptLet’s Encrypt 认证签发为每3个月一次，也就是每 90 天必须更新（renew）一次。取得认证的过程需要进主机安裝代理程序:certbot,下面以ubuntu为例: 安装 12345$ sudo apt-get update$ sudo apt-get install software-properties-common$ sudo add-apt-repository ppa:certbot/certbot$ sudo apt-get update$ sudo apt-get install certbot 生成证书 1$ sudo certbot certonly 此时会出现选项,按照提示选择即可 证书自动续期可以使用1certbot renew --force-renew 手动强制为证书续期如果出现以下提示则说明更新成功1Congratulations, all renewals succeeded. The following certs have been renewed: 但为了更方便,通常使用crontab -e编辑定时任务,并加入10 0 1 * * certbot renew --force-renew “重启服务器命令” 实现每个月1号0点自动续期 在服务器配置相关证书apache2开启SSL tips:如果有多个域名 可以用过在Please enter in your domain name(s) (comma and/or space separated) (Enter &#39;c&#39; to cancel):步骤通过,来分隔域名 可以使用以下命令来直接生成多个域名的证书 1$ sudo certbot certonly --webroot -w /var/www/example -d example.com -d www.example.com -w /var/www/thing -d thing.is -d m.thing.is 生成的证书通常保存在/etc/letsencrypt/live/目录下 注意:如果失败超过5次会被服务器屏蔽1小时 后记以上操作完成后在pc端浏览器可正常读取证书并显示绿色锁,但在部分移动端浏览器上可能提示证书无效,原因可以参考合并SSL服务器证书和CA包(证书链文件) 简单来说,可以通过合并SSL服务器证书和CA包(证书链文件)即:复制fullchain.pem里的内容至cert.pem,重启服务器即可]]></content>
      <tags>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次centos6排查80端口无法访问的问题]]></title>
    <url>%2F2017%2F12%2F28%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1centos6%E6%8E%92%E6%9F%A580%E7%AB%AF%E5%8F%A3%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[大概是一个月前的事情了,最近工作繁忙,暂时忘了记录… 当时的情况大概是这样:客户的机房开通的是广电网的固定IP,服务器系统是 centos6.8,已知 80 端口和 22 端口对外是开放并能访问的;服务器上有两个 web 项目,一个对应 80 端口,一个对应 8080 端口web 服务器是 apache2.2,目前监听了 80 和 8080 端口,httpd-vhosts.conf 下有两个虚拟机配置,分别对应 80 和 8080 端口;防火墙状态:service iptables status(iptables：未运行防火墙。)SELinux 状态:getenforce (Disabled)项目目录的访问权限是足够的1234567891011121314151617181920212223242526272829lsof -i :8080httpd 22357 root 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 22431 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 22433 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 22478 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 22668 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN) httpd 22690 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 23028 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 23030 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 23760 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 23761 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 23762 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)httpd 23855 www 6u IPv6 27111118 0t0 TCP *:webcache (LISTEN)netstat -nlptActive Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 0.0.0.0:58726 0.0.0.0:* LISTEN 2630/rpc.statdtcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 6324/mysqldtcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN 2574/rpcbindtcp 0 0 0.0.0.0:21 0.0.0.0:* LISTEN 3235/pure-ftpd (SER tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 3941/sshdtcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 2668/cupsdtcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 3109/sendmailtcp 0 0 :::34760 :::* LISTEN 2630/rpc.statdtcp 0 0 :::111 :::* LISTEN 2574/rpcbindtcp 0 0 :::8080 :::* LISTEN 22357/httpdtcp 0 0 :::80 :::* LISTEN 22357/httpdtcp 0 0 :::21 :::* LISTEN 3235/pure-ftpd (SER tcp 0 0 :::22 :::* LISTEN 3941/sshdtcp 0 0 ::1:631 :::* LISTEN 2668/cupsdtcp 0 0 :::443 :::* LISTEN 22357/httpd 问题: 服务器的 8080 端口在本地可以通过 curl 命令(curl http://localhost:8080)获取到 index.php 的内容,但是外网无法通过 ip:port 的形式访问到 最后锁定问题:8080端口被机房限制了… NOTE:这种情况通常排查机房或运营商是否对无法访问的端口进行了限制附上本人当时在v2ex上发的主题]]></content>
      <tags>
        <tag>centos6</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SoapClient的一点总结]]></title>
    <url>%2F2017%2F12%2F18%2FSoapClient%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[近期在开发一个小型的酒店订房系统 应用场景:由于是在公司之前一个订房系统基础上进行修改,因此工作量不算大,但需要在系统中多个位置和酒店方提供的另一个PMS系统的信息进行对接(部分数据需要同步[库存,房间编号,订单信息等等]),接口使用xml格式进行数据传递,后端开发语言是php 问题:开发中遇到的一个坑就是使用SoapClient在调用PMS系统接口的时候会出现间歇性404(Solution: Soap WSDL Error - “failed to load external entity”) 解决方法:向PMS接口提供方反应这个情况之后那边说接口正常,后来网上查阅才发现需要使用libxml_disable_entity_loader(false)这个函数来打开entity_loader,随即问题解决.该函数通常添加在需要使用SoapClient实例的脚本上方]]></content>
      <tags>
        <tag>Soap</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpexcel踩坑记]]></title>
    <url>%2F2017%2F12%2F01%2Fphpexcel%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近在使用phpexcel扩展处理表格导入的时候,遇到两个坑,现做以下记录 坑一:excel表中的富文本导入后数据始终不对 解决方法:假设$temp为循环读取的每列数据值,判断是否是PHPExcel_RichText类的实例,如果是,则调用$temp自身的方法__toString()转换,代码如下: 1if ($temp instanceof PHPExcel_RichText) $temp = $temp-&gt;__toString(); 坑二:excel表中的日期导入后变成了float类型的值 解决方法:假设$temp为循环读取的每列数据值,假设日期所在列为D代码如下(这里的if仅仅是用来判断日期是否为空,如果不判断,为空时会自动用当前时间填充,根据实际业务决定): 12345678910if($k=='D')&#123;//指定D列为时间所在列 $date = $objPHPExcel-&gt;getActiveSheet()-&gt;getCell("$k$j")-&gt;getValue(); if($date)&#123; $temp = date("Y-m-d", PHPExcel_Shared_Date::ExcelToPHP($date)); &#125;else&#123; $temp = ''; &#125;&#125;else&#123; $temp = $objPHPExcel-&gt;getActiveSheet()-&gt;getCell("$k$j")-&gt;getValue();&#125; 目前暂未发现其他坑]]></content>
      <tags>
        <tag>php</tag>
        <tag>excel</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个投票项目的总结]]></title>
    <url>%2F2017%2F11%2F20%2F%E4%B8%80%E4%B8%AA%E6%8A%95%E7%A5%A8%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近开发了一个只有3个页面的微信投票小项目基本流程:一个微信号一天只能对一个参与者投一次票且一天总共可以对不同参与者投10次票首页内容:展示所有投票参与者以及其得票数,按照编号排序(支持点击投票)排行页内容:展示所有投票参与者以及其得票数,按照得票数排序详情页内容:展示指定参与者以及其得票数(支持点击投票)后台略过…项目上线后服务器cpu长时间负载100%,仔细查看后发现几个主要问题: 首页和详情页js中没有对触发异步请求的请求中状态(已发出请求且未收到响应[搜索,下一页加载,投票操作])没有禁用处理和提示,可能导致用户连续点击操作,挂起多个请求解决方法:添加对应请求中的状态,在发出请求后,收到响应前都无法再次发出相同请求 之前有对三个页面的访问量进行统计,但用的是简单粗暴每次访问都直接更新数据库的响应字段值,导致并发增加时数据库写入次数过多解决方法:配置一个值,每次请求时先将总访问量+1,再判断如果等于配置值,则更新数据库的总访问量并清空缓存,反之写入缓存 忘了关闭TP框架的调试模式(调试模式会使模板缓存和字段缓存失效)解决方法:关闭调试模式 mysql数据表的联合索引没有生效(原因待定)]]></content>
      <tags>
        <tag>并发</tag>
        <tag>缓存</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ab测试中并发量导致的拒绝问题]]></title>
    <url>%2F2017%2F11%2F15%2Fab%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B9%B6%E5%8F%91%E9%87%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8B%92%E7%BB%9D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天对一个微信投票的小项目进行ab测试环境:windows 10+cmd(管理员身份)问题:在输入了ab -n 5000 -c 500 http://hostname/并enter之后等待片刻出现了apr_socket_connect():由于目标计算机积极拒绝，无法连接。(730061)在网上找到了其他人的方法,参考后,问题解决解决方法:找到http.conf,打开,找到关于httpd-mpm.conf的引用配置,如果没有引用,则去掉#,反之则无视,打开httpd-mpm.conf文件,将其中的ThreadsPerChild参数值调大,重启Apache即可 补充:在后续的测试中遇到了apr_poll: The timeout specified has expired (70007)的提示解决方法:使用-k参数(Connection: Keep-Alive)]]></content>
      <tags>
        <tag>压力测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[head标签中自动设置ie内核版本的写法]]></title>
    <url>%2F2017%2F11%2F11%2Fhead%E6%A0%87%E7%AD%BE%E4%B8%AD%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AEie%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E7%9A%84%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在开发中遇到后台管理系统部分样式,js对IE浏览器不兼容的情况,最后通过在head标签中添加如下代码实现自动设置IE内核版本解决: 123&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,Chrome=1" /&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=9" /&gt;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>IE</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用apache2反向代理访问google]]></title>
    <url>%2F2017%2F10%2F14%2F%E4%BD%BF%E7%94%A8apache2%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AEgoogle%2F</url>
    <content type="text"><![CDATA[引言刚刚在v2ex上看到一篇用nginx做反向代理访问google的帖子,出于好奇,试了试用apache进行反向代理访问google,果然很好玩! 准备工作: apache服务器需要安装proxy相关模块,如果是ubuntu环境可以直接使用命令sudo a2enmod 模块名称进行安装,模块可以在/etc/apache2/mods-available/目录下查看,安装好的模块可以在/etc/apache2/mods-enabled/里查看这里直接上本人的配置:&lt;VirtualHost *:443&gt; ServerName facebook.smarthippo.club SSLEngine on SSLCertificateFile &quot;/etc/letsencrypt/archive/facebook.smarthippo.club/cert1.pem&quot; SSLCertificateKeyFile &quot;/etc/letsencrypt/archive/facebook.smarthippo.club/privkey1.pem&quot; SetEnvIf User-Agent “.*MSIE.*” \ nokeepalive ssl-unclean-shutdown \ downgrade-1.0 force-response-1.0 SSLProxyEngine On ProxyPass / https://www.facebook.com/ ProxyPassReverse / https://www.facebook.com/ &lt;/VirtualHost&gt; &lt;VirtualHost *:443&gt; ServerName google.smarthippo.club SSLEngine on SSLCertificateFile &quot;/etc/letsencrypt/archive/google.smarthippo.club/cert1.pem&quot; SSLCertificateKeyFile &quot;/etc/letsencrypt/archive/google.smarthippo.club/privkey1.pem&quot; SetEnvIf User-Agent “.*MSIE.*” \ nokeepalive ssl-unclean-shutdown \ downgrade-1.0 force-response-1.0 SSLProxyEngine On ProxyPass / https://www.google.com.hk/ ProxyPassReverse / https://www.google.com.hk/ &lt;/VirtualHost&gt; So,Google,Wiki,就是这么简单~ 备注:这篇文章的前提当然是有一个国外的服务器,安利一波vultr(价格合理,且稳定,按天计费)可以通过添加子域名的方式实现对不同墙外站点的访问,详见第二个配置安装ssl证书网上太多,就不写了 目前存在的问题: 在反向代理站点中如果有跳转到其他被墙站点的链接,依然无法访问 部分网站对机器访问的请求有限制,比如google,虽然首页可以正常访问,但其他页面可能会访问不了,跳转到ipv4.google.com进行人机验证 正在尝试用apache的负载均衡解决第二个问题…]]></content>
      <tags>
        <tag>翻墙</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常用正则表达式]]></title>
    <url>%2F2017%2F10%2F14%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近用phpspider抓取网页,除了用xpath匹配标签外,偶尔也会用到正则表达式,这里简单记录一下常用的正则如下: 1234567891011121314151617181920212223242526272829$str=preg_replace("/\s+/", " ", $str); //过滤多余回车$str=preg_replace("/&lt;[ ]+/si","&lt;",$str); //过滤&lt;__("&lt;"号后面带空格)$str=preg_replace("/&lt;\!--.*?--&gt;/si","",$str); //注释$str=preg_replace("/&lt;(\!.*?)&gt;/si","",$str); //过滤DOCTYPE$str=preg_replace("/&lt;(\/?html.*?)&gt;/si","",$str); //过滤html标签$str=preg_replace("/&lt;(\/?head.*?)&gt;/si","",$str); //过滤head标签$str=preg_replace("/&lt;(\/?meta.*?)&gt;/si","",$str); //过滤meta标签$str=preg_replace("/&lt;(\/?body.*?)&gt;/si","",$str); //过滤body标签$str=preg_replace("/&lt;(\/?link.*?)&gt;/si","",$str); //过滤link标签$str=preg_replace("/&lt;(\/?form.*?)&gt;/si","",$str); //过滤form标签$str=preg_replace("/cookie/si","COOKIE",$str); //过滤COOKIE标签$str=preg_replace("/&lt;(applet.*?)&gt;(.*?)&lt;(\/applet.*?)&gt;/si","",$str); //过滤applet标签$str=preg_replace("/&lt;(\/?applet.*?)&gt;/si","",$str); //过滤applet标签$str=preg_replace("/&lt;(style.*?)&gt;(.*?)&lt;(\/style.*?)&gt;/si","",$str); //过滤style标签$str=preg_replace("/&lt;(\/?style.*?)&gt;/si","",$str); //过滤style标签$str=preg_replace("/&lt;(title.*?)&gt;(.*?)&lt;(\/title.*?)&gt;/si","",$str); //过滤title标签$str=preg_replace("/&lt;(\/?title.*?)&gt;/si","",$str); //过滤title标签$str=preg_replace("/&lt;(object.*?)&gt;(.*?)&lt;(\/object.*?)&gt;/si","",$str); //过滤object标签$str=preg_replace("/&lt;(\/?objec.*?)&gt;/si","",$str); //过滤object标签$str=preg_replace("/&lt;(noframes.*?)&gt;(.*?)&lt;(\/noframes.*?)&gt;/si","",$str); //过滤noframes标签$str=preg_replace("/&lt;(\/?noframes.*?)&gt;/si","",$str); //过滤noframes标签$str=preg_replace("/&lt;(i?frame.*?)&gt;(.*?)&lt;(\/i?frame.*?)&gt;/si","",$str); //过滤frame标签$str=preg_replace("/&lt;(\/?i?frame.*?)&gt;/si","",$str); //过滤frame标签$str=preg_replace("/&lt;(script.*?)&gt;(.*?)&lt;(\/script.*?)&gt;/si","",$str); //过滤script标签$str=preg_replace("/&lt;(\/?script.*?)&gt;/si","",$str); //过滤script标签$str=preg_replace("/javascript/si","Javascript",$str); //过滤script标签$str=preg_replace("/vbscript/si","Vbscript",$str); //过滤script标签$str=preg_replace("/on([a-z]+)\s*=/si","On\\1=",$str); //过滤script标签$str=preg_replace("/&amp;#/si","&amp;＃",$str); //过滤script标签，如javaSCript:alert]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2017%2F09%2F19%2F%E8%BF%91%E5%86%B5%2F</url>
    <content type="text"><![CDATA[今下午请假去🏥检查腰椎,好在没什么大问题,但是医生建议的不要长时间坐…对我来说也只能尽可能缩短一次连续坐的时间从上个星期开始在做一个小型的微信端餐饮相关商城开发我打算在这个项目中尝试使用php服务端渲染页面+vue.js处理前端所有数据交互,数据库还是mysql,运行环境依然是lamp工作之余尽量安排一些时间学习ES6语法,vue.js单页面应用的项目结构和vue.js的路由,babel自动编译开发环境的部署ok,先就这样吧1die('Happy Hacking!');]]></content>
      <tags>
        <tag>生活</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp3.2.3实现支持点击排序]]></title>
    <url>%2F2017%2F09%2F14%2Ftp3-2-3%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[假设: Admin/Home/Controller/BaseController.class.php是一个基础控制器 $current_params和$in是两个在Admin/Home/Controller/BaseController.class.php中用来保存接收参数的属性,并且已经在构造函数中对其赋值 Admin/Tpl/Index/footer.html是布局中的公共部分 Public/Model/BaseModel.class.php是公共模型 请求中用来表示模块,控制器,操作的参数名称分别为:m,c,a #searchForm和#excelForm分别为条件搜索form和excel表单导出请求提交时用来临时保存和传递筛选条件的form 全局改动Admin/Home/Controller/BaseController.class.php改动:新增protected $current_params属性_initialize方法尾部新增以下代码(用于处理传入的有效参数):1234unset($this-&gt;current_params['m']);unset($this-&gt;current_params['c']);unset($this-&gt;current_params['a']);$this-&gt;assign('page_url', U(CONTROLLER_NAME.'/'.ACTION_NAME,$this-&gt;current_params)); 控制器尾部新增以下方法:123456789101112131415161718/* * todo:处理排序请求 * @param $sort string 用来mysql排序的字符串 * @param $column string 用来指定排序字段名称 * @param $value int 排序值,1:顺序;2:倒序 * @param $table string 需要排序字段在当前sql语句中表的别名 * @return string 返回处理后的$order * */protected function assembleSort($sort,$column,$value,$table)&#123; $order = urldecode($sort); $v_sort[$column] = $value == 1 ? 2 : 1; $v_sort['param_sort'] = $sort; $v_sort['param_column'] = $column; $v_sort['param_value'] = $v_sort[$column]; $v_sort['param_table'] = $table; $this-&gt;assign('sort', $v_sort); return $order;&#125; Admin/Tpl/Index/footer.html改动:在&lt;/body&gt;标签前新增以下代码:html(保存当前页面并携带除排序相关参数的url):1&lt;input type="hidden" id="page_url" value="&#123;&#123;$page_url&#125;&#125;"&gt; js:1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * todo:全局监听并处理点击排序操作 * */ $(function()&#123; var form = $('#searchForm'); if(typeof(form) !== 'undefined')&#123; form.append("&lt;input class='excel' type='hidden' name='sort' value='&#123;&#123;$sort.param_sort&#125;&#125;'/&gt;&lt;input class='excel' type='hidden' name='column' value='&#123;&#123;$sort.param_column&#125;&#125;'/&gt;&lt;input class='excel' type='hidden' name='value' value='&#123;&#123;$sort.param_value&#125;&#125;'/&gt;&lt;input class='excel' type='hidden' name='table' value='&#123;&#123;$sort.param_table&#125;&#125;'/&gt;"); &#125; $('th[data-sort=1]').attr('class','sortable').append('🔻'); $('th[data-sort=2]').attr('class','sortable').append('🔺'); $('tr').delegate('th','click',function()&#123; var sort = $(this).attr('data-sort'); var param = ``; if(typeof(sort) !== 'undefined')&#123; var order = ``; var column = $(this).attr('data-column'); var table = $(this).attr('data-table') ? $(this).attr('data-table') + '.' : ''; if(sort == 1)&#123; order = 'asc' &#125;else if(sort == 2)&#123; order = 'desc'; &#125; param = `$&#123;table&#125;$&#123;column&#125; $&#123;order&#125;`; var url = $('#page_url').val() + '&amp;sort=' + param + '&amp;column=' + column + '&amp;value=' + sort + '&amp;table=' + table; location.href = url; &#125; &#125;); &#125;); /* * todo:处理导出excel操作 * */ if(typeof($('#excel')) !== 'undefined')&#123; $('#excel').click(function () &#123; ui.confirm('确定导出吗', function () &#123; var eform = $('#excelform'); if ($('#data').find('tr').length &lt; 2) &#123; ui.error('没有可以导出的数据'); return false; &#125; eform.html($('.excel').clone()); eform.submit(); &#125;); &#125;); &#125; Public/Model/BaseModel.class.php改动:修改getPage和getExcel方法如下:123456789101112131415161718192021222324/** * todo:获取列表记录并返回分页数据 * @param $map array 筛选条件 * @param $order string 排序规则 */public function getPage($map, $order = '')&#123; $count = $this-&gt;where($map)-&gt;count(); $page = classPage($count); $row['info'] = $this-&gt;where($map)-&gt;order($order)-&gt;limit($page-&gt;firstRow, $page-&gt;listRows)-&gt;select(); $row['page'] = $page-&gt;show(); return $row;&#125;/** * todo:获取导出到excel的数据集合 * @param $map array 筛选条件 * @param $order string 排序规则 */public function getExcel($map,$order = '')&#123; $data = $this-&gt;where($map)-&gt;order($order)-&gt;select(); return $data;&#125; Admin/root/static/css/shop_manager.css改动:在尾部新增(用于控制可点击th样式):1234.sortable&#123; cursor: pointer; color:orangered;&#125; 局部改动controller在相关controller中的列表方法(通常是index)中,新增一行:1$order = $this-&gt;assembleSort($this-&gt;in['sort'], $this-&gt;in['column'], $this-&gt;in['value'], $this-&gt;in['table']); 并将之前1$data = $model-&gt;getPage($where); 改为:1$data = $model-&gt;getPage($where, $order); 在相关控制器中的导出到excel方法(通常是excel)中,做上述相同处理 view在相关view中,修改需要排序的字段的th标签如下:1&lt;th width="180px" data-sort="&#123;&#123;$sort.create_time|default=1&#125;&#125;" data-column="create_time" data-table="A"&gt;添加时间&lt;/th&gt; 参数备注: 1&lt;th width="180px" data-sort="&#123;&#123;$sort.需要排序的字段名称|default=默认值1:当前为倒序,2:当前为顺序&#125;&#125;" data-column="需要排序的字段名称" data-table="如果当前列表需要通过join查询,此处为该字段所属的表别名"&gt;添加时间&lt;/th&gt; 其它备注: 如果当前页面需要接收参数,如:配送点下面的配送元员列表,则需要在#searchForm的form中新增一个input标签:&lt;input type=&quot;hidden&quot; class=&quot;excel&quot; name=&quot;point_id(参数名称)&quot; value=&quot;(参数值)&quot;&gt; 在所有重写了BaseModel的getPage或getExcel方法的模型中都需要做相应修改]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql开发规范]]></title>
    <url>%2F2017%2F09%2F12%2Fmysql%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[命名规范 库名、表名、字段名必须使用小写字母，并采用下划线分割 库名、表名、字段名禁用超过32个字符。须见名知意 库名、表名、字段名禁用使 MySQL保留字 临时库、表名必须以tmp为前缀，并以日期为后缀 备份库、表必须以bak为前缀，并以日期为后缀 基础规范 使用INNODB存储引擎 表字符集使用utf8mb4 所有表都需要添加注释 单表数据量建议控制在5000W以内 不在数据库中存储图片、文件等大数据 禁止在线上做数据库压力测试 禁止从测试、开发环境直连数据库 库表设计 禁止使用分区表 拆分大字段和访问频率低的字段，分离冷热数据 HASH进行散表，表名后缀使用十进制数，下标从0开始 按日期时间分表需符合YYYY[MM][DD][HH]格式 采用合适的分库分表策略。例如千库十表、十库百表等 字段设计 尽可能不使用TEXT、BLOB类型 DECIMAL代替FLOAT和DOUBLE存储精确浮点数 Simple is good 将字符转化为数字 使用TINYINT来代替ENUM类型 Generosity can be unwise 存储 “hello”时VARCHAR(5) VS VARCHAR(200) Avoid null if possible 所有字段均定义为NOT NULL ! Smaller is usually better 使用UNSIGNED存储非负整数 INT类型固定占用4字节存储 使用timestamp存储时间 使用INT UNSIGNED存储IPV4 使用VARBINARY存储大写敏感的变 字符串 禁用在数据库中存储明文密码 索引规范索引的用途 去重 加速定位 避免排序 覆盖索引 索引数量控制 单张表中索引数量不超过5个 单个索引中的字段数不超过5个 对字符串使用前缀索引，前缀索引长度不超过8个字符 建议优先考虑前缀索引，必要时可添加伪列并建立索引 主键准则 表必须有主键 不使用更新频繁的列 尽量不选择字符串列 不使用UUID MD5 HASH 默认使用非空的唯一键 建议选择自增或发号器 重要的SQL必须被索引 UPDATE、DELETE语句的WHERE条件列 ORDER BY、GROUP BY、DISTINCT的字段 多表JOIN的字段 区分度最大的字段放在前核心SQL优先考虑覆盖索引避免冗余和重复索引索引不是越多越好 综合评估数据密度和分布 考虑查询和更新比例]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017/10/01-10/07 成都-泸沽湖-洱海自驾游]]></title>
    <url>%2F2017%2F09%2F08%2Fnational-day-holiday-travels%2F</url>
    <content type="text"><![CDATA[住宿安排10月1日4点从成都出发这是大概6点左右的成雅高速大概中下午1点到了西昌,随意在路边吃了个干锅鸡,然后去酒店放了行李,睡个觉,就去琼海边上溜达了这个是琼海,还行,比较空旷,空气不错晚上在西昌吃了当地的羊肉米粉 10月2日全程307省道,从西昌经盐源县到泸沽湖,大概7小时,260公里山路,路上有点堵我们入住的泸沽湖阿塔兄弟之家的晚餐,还不错,比较有当地特色的菜 10月3日当天晚上依然在阿塔兄弟之家吃的饭,店里还有一只金毛 10月4日准备离开泸沽湖,出发去大理,下面这张图是早晨7点多拍到的日出,还不错当天下午4点多到了大理古城,本想去点评上人气高的段公子,奈何人太多,结果去旁边吃过桥米线了(以后再也不想吃了),当天晚上去古城里逛了一下, 就回客栈睡觉去了 10月5日去喜洲镇,海舌公园玩了大半天,本来要去双廊,结果当地’施工’,没去晚上去当地一家不错的东北小馆吃了粥和葱油面(个人认为比过桥米线好吃吧),逛了下古城一家比较有特点的麦当劳当地的鸡丝米线(老婆说味道不错) 10月6日开车从大理经杭瑞高速转那个什么省道(忘了)经元谋县到攀枝花,结束这次泸沽湖大理之旅下面是在元谋县附近经过的一个变形金刚(忘了哪一部)的拍摄地 备注 本次行程2262公里时间:2017.10.01-2017.10.07]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>自驾游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache2开启SSL]]></title>
    <url>%2F2017%2F09%2F08%2Fapache2-ssl%2F</url>
    <content type="text"><![CDATA[windows+apache2开启SSL以及80端口强制跳转SSL访问的方法申请证书推荐Let’s Encrypt(免费证书的有效期为3个月,但提供了自动更新证书的功能),也可以用阿里云(免费证书有效期1年,目前是手动更新) 开启ssl模块首先确保apache开启了LoadModule ssl_module modules/mod_ssl.so 配置443端口再参考官方文档的一段内容:12345678Listen 443&lt;VirtualHost *:443&gt; DocumentRoot "项目入口文件目录" ServerName 域名 SSLEngine on SSLCertificateFile "路径/文件名.cert" SSLCertificateKeyFile "路径/文件名.key"&lt;/VirtualHost&gt; 在apache的vhosts.conf中添加以上代码,重启apache 配置80端口跳转443这里直接上代码:123456&lt;VirtualHost *:80&gt; RewriteEngine on RewriteCond %&#123;SERVER_PORT&#125; !^443$ RewriteRule ^/?(.*)$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R] ServerName 域名&lt;/VirtualHost&gt; 告诉apache将该域名下80端口的所有请求跳转到443,重启apache 至此配置完成在ubuntu环境下配置基本一样,开启apache ssl模块支持使用sudo a2enmod ssl,然后重启service apache2 restart 补充:后面在一个微信项目中发现以上做法的一个问题:安卓手机在使用微信内置浏览器QQ浏览器X5内核提供技术支持访问可能会出现页面空白的情况,而在PC端的调试工具和IOS以及其他浏览器上未发现该问题解决方法:修改虚拟机配置如下:`Listen 443 DocumentRoot “项目入口文件目录” ServerName 域名 SSLEngine on SSLCertificateFile “路径/文件名.cert” SSLCertificateKeyFile “路径/文件名.key” SSLCertificateChainFile “路径/文件名.pem”` 其实就是添加了一行SSLCertificateChainFile]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[油猴的简单使用]]></title>
    <url>%2F2017%2F09%2F05%2Fgrease-monkey%2F</url>
    <content type="text"><![CDATA[关于greasemonkey(油猴)的安装和一些实用脚本推荐步骤准备工作:确保你的电脑可以科学上网以本人的chrome浏览器为例 1. 打开一个新标签页2. 地址栏输入chrome://apps/3. 页面右下角选择网上应用店4. 搜索greasemonkey,如图: 5. 点击安装,完成安装后在如图位置会出现一个图标 6. 点击获取新脚本跳转到一个页面,在当前页面中点击途中位置 7. 会跳转到Greasy Fork的搜索页,在搜索框中输入userscript+点击enter8. 在出现的结果中选择 其他 greasemonkey(油猴子介绍)简单说是一个可以安装当前正在浏览页面可用的额外功能的脚本,举个栗子:非会员在优酷视频无法观看会员视频,而安装油猴子之后再安装了userscript+脚本就可以自动在当前页面检测可用的脚本(可用脚本的提示将会出现在页面右下角,点击即安装) 介绍一下VIP视频破解脚本用法用优酷举例吧,直接上图 1. 首页点击会员 2. 随便选择一个视频 3. 视频播放窗口左上角可以切换通道(部分通道可能无法播放,不过选择超多) 本文仅供心得交流,请自觉购买会员支持正版!关于科学上网请自行baidu]]></content>
      <categories>
        <category>其他交流</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
</search>
